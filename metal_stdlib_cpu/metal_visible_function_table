// -*- Metal -*-
//===-- metal_visible_function_table --------------------------------------===//
// Copyright (c) 2020 Apple Inc. All rights reserved
//===----------------------------------------------------------------------===//

#ifndef __METAL_VISIBLE_FUNCTION_TABLE
#define __METAL_VISIBLE_FUNCTION_TABLE

#if defined(__HAVE_VISIBLE_FUNCTION_TABLE__)

namespace metal
{

template <typename T>
struct visible_function_table;

template <typename T>
METAL_FUNC bool is_null_visible_function_table(visible_function_table<T> vft);

template <typename R, typename... Args>
struct visible_function_table<R(Args...)>
{
  using function_pointer_type = R(*)(Args...) [[visible]];

  METAL_FUNC visible_function_table() thread : t(__metal_get_null_visible_function_table())
  {
  }
  METAL_FUNC visible_function_table() constant : t(__metal_get_null_visible_function_table())
  {
  }
  METAL_FUNC visible_function_table() ray_data : t(__metal_get_null_visible_function_table())
  {
  }

  METAL_FUNC visible_function_table(const thread visible_function_table &) thread = default;
  METAL_FUNC visible_function_table(const device visible_function_table &) thread = default;
  METAL_FUNC visible_function_table(const constant visible_function_table &) thread = default;
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC visible_function_table(const ray_data visible_function_table &) thread = default;
#endif
  METAL_FUNC visible_function_table(const thread visible_function_table &) constant = default;
  METAL_FUNC visible_function_table(const device visible_function_table &) constant = default;
  METAL_FUNC visible_function_table(const constant visible_function_table &) constant = default;
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC visible_function_table(const ray_data visible_function_table &) constant = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC visible_function_table(const thread visible_function_table &) ray_data = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC visible_function_table(const device visible_function_table &) ray_data = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC visible_function_table(const constant visible_function_table &) ray_data = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC visible_function_table(const ray_data visible_function_table &) ray_data = default;
#endif

  METAL_FUNC thread visible_function_table &operator=(const thread visible_function_table &) thread = default;
  METAL_FUNC thread visible_function_table &operator=(const device visible_function_table &) thread = default;
  METAL_FUNC thread visible_function_table &operator=(const constant visible_function_table &) thread = default;
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread visible_function_table &operator=(const ray_data visible_function_table &) thread = default;
#endif
  METAL_FUNC device visible_function_table &operator=(const thread visible_function_table &) device = default;
  METAL_FUNC device visible_function_table &operator=(const device visible_function_table &) device = default;
  METAL_FUNC device visible_function_table &operator=(const constant visible_function_table &) device = default;
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device visible_function_table &operator=(const ray_data visible_function_table &) device = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data visible_function_table &operator=(const thread visible_function_table &) ray_data = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data visible_function_table &operator=(const device visible_function_table &) ray_data = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data visible_function_table &operator=(const constant visible_function_table &) ray_data = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data visible_function_table &operator=(const ray_data visible_function_table &) ray_data = default;
#endif

  METAL_FUNC function_pointer_type operator[](uint idx) const thread
  {
    return reinterpret_cast<function_pointer_type>(__metal_get_function_pointer_visible_function_table(t, idx));
  }
  METAL_FUNC function_pointer_type operator[](uint idx) const device
  {
    return reinterpret_cast<function_pointer_type>(__metal_get_function_pointer_visible_function_table(t, idx));
  }
  METAL_FUNC function_pointer_type operator[](uint idx) const constant
  {
    return reinterpret_cast<function_pointer_type>(__metal_get_function_pointer_visible_function_table(t, idx));
  }
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC function_pointer_type operator[](uint idx) const ray_data
  {
    return reinterpret_cast<function_pointer_type>(__metal_get_function_pointer_visible_function_table(t, idx));
  }
#endif

  METAL_FUNC bool empty() const thread
  {
    return size() == 0;
  }
  METAL_FUNC bool empty() const device
  {
    return size() == 0;
  }
  METAL_FUNC bool empty() const constant
  {
    return size() == 0;
  }
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC bool empty() const ray_data
  {
    return size() == 0;
  }
#endif

  METAL_FUNC uint size() const thread
  {
    return __metal_get_size_visible_function_table(t);
  }
  METAL_FUNC uint size() const device
  {
    return __metal_get_size_visible_function_table(t);
  }
  METAL_FUNC uint size() const constant
  {
    return __metal_get_size_visible_function_table(t);
  }
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint size() const ray_data
  {
    return __metal_get_size_visible_function_table(t);
  }
#endif

private:
  __metal_visible_function_table_t t;

  friend bool metal::is_null_visible_function_table<R(Args...)>(visible_function_table<R(Args...)>);
};

template <typename T>
METAL_FUNC bool is_null_visible_function_table(visible_function_table<T> vft)
{
  return __metal_is_null_visible_function_table(vft.t);
}

} // namespace metal

#endif // __HAVE_VISIBLE_FUNCTION_TABLE__
#endif // __METAL_VISIBLE_FUNCTION_TABLE
